"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateArraySchema = exports.validateSchema = exports.withdrawDelegatedStakeSchema = exports.delegatedStakeSchema = exports.postTokenLockSchema = exports.tokenLockSchema = exports.postAllowSpendSchema = exports.allowSpendSchema = exports.currencyIdValidator = exports.zeroPositive = exports.nonEmptyString = exports.dagAddressValidator = void 0;
const zod_1 = require("zod");
const dag4_keystore_1 = require("@stardust-collective/dag4-keystore");
/**
 * Validator for DAG addresses
 */
exports.dagAddressValidator = zod_1.z
    .string()
    .refine((value) => dag4_keystore_1.keyStore.validateDagAddress(value), {
    message: "Must be a valid DAG address",
});
/**
 * Validator for non-zero numbers
 */
const nonZeroNumber = zod_1.z
    .number()
    .positive("Must be greater than zero")
    .refine((value) => value !== 0, {
    message: "Cannot be zero",
});
/**
 * Validator for non-empty strings
 */
exports.nonEmptyString = zod_1.z.string().min(1, "String cannot be empty");
/**
 * Validator for zero or positive numbers
 */
exports.zeroPositive = zod_1.z.number().min(0, "Must be zero or positive");
/**
 * Validator for the currencyId field
 */
exports.currencyIdValidator = zod_1.z
    .union([zod_1.z.string(), zod_1.z.null()])
    .refine((value) => value === null || dag4_keystore_1.keyStore.validateDagAddress(value), {
    message: "Must be a valid DAG address or null",
});
/**
 * Schema for validating allow spend body
 */
exports.allowSpendSchema = zod_1.z.object({
    source: exports.dagAddressValidator,
    destination: exports.dagAddressValidator,
    amount: nonZeroNumber,
    fee: exports.zeroPositive,
    validUntilEpoch: zod_1.z
        .number()
        .positive("Valid until epoch must be greater than zero"),
});
/**
 * @deprecated Use allowSpendSchema instead. This schema will be removed in the next major version.
 * Schema for validating post allow spend body
 */
exports.postAllowSpendSchema = exports.allowSpendSchema.extend({
    tokenL1Url: exports.nonEmptyString,
    currencyId: exports.currencyIdValidator,
});
/**
 * Schema for validating token lock body
 */
exports.tokenLockSchema = zod_1.z.object({
    source: exports.dagAddressValidator,
    amount: nonZeroNumber,
    fee: exports.zeroPositive,
    unlockEpoch: zod_1.z
        .union([zod_1.z.number(), zod_1.z.null()])
        .refine((value) => value === null || value > 0, {
        message: "Unlock epoch must be greater than zero or null",
    }),
});
/**
 * @deprecated Use tokenLockSchema instead. This schema will be removed in the next major version.
 * Schema for validating post token lock body
 */
exports.postTokenLockSchema = exports.tokenLockSchema.extend({
    tokenL1Url: exports.nonEmptyString,
    currencyId: exports.currencyIdValidator,
});
/**
 * Schema for validating delegated stake body
 */
exports.delegatedStakeSchema = zod_1.z.object({
    source: exports.dagAddressValidator,
    nodeId: exports.nonEmptyString,
    amount: nonZeroNumber,
    fee: exports.zeroPositive,
    tokenLockRef: exports.nonEmptyString,
});
/**
 * Schema for validating withdraw delegated stake body
 */
exports.withdrawDelegatedStakeSchema = zod_1.z.object({
    source: exports.dagAddressValidator,
    stakeRef: exports.nonEmptyString,
});
/**
 * Helper function to validate an object against a Zod schema
 * @param obj - The object to validate
 * @param schema - The Zod schema to validate against
 * @param checkNotEmpty - Whether to check if the object is not empty
 */
function validateSchema(obj, schema, checkNotEmpty = false) {
    if (checkNotEmpty && Object.keys(obj).length === 0) {
        throw new Error("Object cannot be empty");
    }
    return schema.parse(obj);
}
exports.validateSchema = validateSchema;
/**
 * Helper function to validate an array against a Zod schema
 * @param arr - The array to validate
 * @param schema - The Zod schema to validate against
 * @param checkNotEmpty - Whether to check if the array is not empty
 */
function validateArraySchema(arr, schema, checkNotEmpty = false) {
    if (checkNotEmpty) {
        return zod_1.z.array(schema).nonempty("Array cannot be empty").parse(arr);
    }
    return zod_1.z.array(schema).parse(arr);
}
exports.validateArraySchema = validateArraySchema;
//# sourceMappingURL=validationSchemas.js.map