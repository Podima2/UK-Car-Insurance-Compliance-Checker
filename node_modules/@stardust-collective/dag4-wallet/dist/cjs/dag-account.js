"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DagAccount = void 0;
const dag4_core_1 = require("@stardust-collective/dag4-core");
const dag4_keystore_1 = require("@stardust-collective/dag4-keystore");
const dag4_network_1 = require("@stardust-collective/dag4-network");
const bignumber_js_1 = require("bignumber.js");
const rxjs_1 = require("rxjs");
const metagraph_token_client_1 = require("./metagraph-token-client");
const network_config_1 = require("./network-config");
const operations_1 = require("./shared/operations");
const utils_1 = require("./utils");
const validationSchemas_1 = require("./validationSchemas");
class DagAccount {
    constructor(network) {
        this.sessionChange$ = new rxjs_1.Subject();
        this.network = network || dag4_network_1.globalDagNetwork;
    }
    connect(networkInfo, useDefaultConfig = true) {
        let baseConfig = {};
        if (useDefaultConfig) {
            const version = 2; // Defaults to network version 2.0
            const networkType = networkInfo.testnet ? "testnet" : "mainnet";
            baseConfig = network_config_1.networkConfig[version][networkType];
        }
        const networkId = networkInfo.id || "global";
        this.network.config(Object.assign(Object.assign(Object.assign({}, baseConfig), networkInfo), { id: networkId }));
        return this;
    }
    get address() {
        const address = this.m_keyTrio && this.m_keyTrio.address;
        if (!address) {
            throw new Error("Need to login before calling methods on dag4.account");
        }
        return address;
    }
    get keyTrio() {
        return this.m_keyTrio;
    }
    get publicKey() {
        return this.m_keyTrio.publicKey;
    }
    get networkInstance() {
        return this.network;
    }
    loginSeedPhrase(words) {
        const privateKey = dag4_keystore_1.keyStore.getPrivateKeyFromMnemonic(words);
        this.loginPrivateKey(privateKey);
    }
    loginPrivateKey(privateKey) {
        const publicKey = dag4_keystore_1.keyStore.getPublicKeyFromPrivate(privateKey);
        const address = dag4_keystore_1.keyStore.getDagAddressFromPublicKey(publicKey);
        this.setKeysAndAddress(privateKey, publicKey, address);
    }
    loginPublicKey(publicKey) {
        const address = dag4_keystore_1.keyStore.getDagAddressFromPublicKey(publicKey);
        this.setKeysAndAddress("", publicKey, address);
    }
    isActive() {
        return !!this.m_keyTrio;
    }
    assertAccountIsActive() {
        if (!this.isActive() || !this.address) {
            throw new Error("Account is not active. Make sure to login before calling this method");
        }
    }
    logout() {
        this.m_keyTrio = null;
        this.sessionChange$.next(true);
    }
    observeSessionChange() {
        return this.sessionChange$;
    }
    setKeysAndAddress(privateKey, publicKey, address) {
        this.m_keyTrio = new dag4_keystore_1.KeyTrio(privateKey, publicKey, address);
        this.sessionChange$.next(true);
    }
    getTransactions(limit, searchAfter) {
        return this.network.getTransactionsByAddress(this.address, limit, searchAfter);
    }
    getActions(actionType, limit, searchAfter, searchBefore, next) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const actions = yield this.network.blockExplorerV2Api.getActionsByAddress(this.address, actionType, limit, searchAfter, searchBefore, next);
            if (!((_a = actions === null || actions === void 0 ? void 0 : actions.data) === null || _a === void 0 ? void 0 : _a.length))
                return [];
            return actions.data.filter(action => action.source === this.address);
        });
    }
    assertValidPrivateKey() {
        if (!this.m_keyTrio.privateKey) {
            throw new Error("Private key not found. Make sure to login with dag4.account.loginPrivateKey() or dag4.account.loginSeedPhrase()");
        }
    }
    validateDagAddress(address) {
        return dag4_keystore_1.keyStore.validateDagAddress(address);
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getBalanceFor(this.address);
        });
    }
    getBalanceFor(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const addressObj = yield this.network.getAddressBalance(address);
            if (addressObj && !isNaN(addressObj.balance)) {
                return new bignumber_js_1.BigNumber(addressObj.balance)
                    .multipliedBy(dag4_core_1.DAG_DECIMALS)
                    .toNumber();
            }
            return 0;
        });
    }
    getActiveTokenLocksTransactions(limit, searchAfter, searchBefore) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const activeTokenLocks = [];
            let next;
            do {
                const response = yield this.network.blockExplorerV2Api.getTokenLocksByAddress(this.address, limit, searchAfter, searchBefore, next, true);
                if (response === null || response === void 0 ? void 0 : response.data) {
                    activeTokenLocks.push(...response.data);
                }
                next = (_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.next;
            } while (next);
            return activeTokenLocks;
        });
    }
    ;
    getActiveAllowSpendsTransactions(limit, searchAfter, searchBefore) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const activeAllowSpends = [];
            let next;
            do {
                const response = yield this.network.blockExplorerV2Api.getAllowSpendsByAddress(this.address, limit, searchAfter, searchBefore, next, true);
                if (response === null || response === void 0 ? void 0 : response.data) {
                    activeAllowSpends.push(...response.data);
                }
                next = (_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.next;
            } while (next);
            return activeAllowSpends;
        });
    }
    ;
    getLockedBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const [tokenLocks, allowSpends] = yield Promise.all([
                this.getActiveTokenLocksTransactions(),
                this.getActiveAllowSpendsTransactions()
            ]);
            let lockedAmount = new bignumber_js_1.BigNumber(0);
            if (tokenLocks.length > 0) {
                for (const tokenLock of tokenLocks) {
                    lockedAmount = lockedAmount.plus(new bignumber_js_1.BigNumber(tokenLock.amount));
                }
            }
            if (allowSpends.length > 0) {
                for (const allowSpend of allowSpends) {
                    if (allowSpend.source === this.address) {
                        lockedAmount = lockedAmount.plus(new bignumber_js_1.BigNumber(allowSpend.amount));
                    }
                }
            }
            // Returns locked amount in DAG
            return lockedAmount.multipliedBy(dag4_core_1.DAG_DECIMALS).toNumber();
        });
    }
    getFeeRecommendation() {
        return __awaiter(this, void 0, void 0, function* () {
            //Get last tx ref
            const lastRef = (yield this.network.getAddressLastAcceptedTransactionRef(this.address));
            const hash = lastRef.prevHash || lastRef.hash; // v1 vs v2 format
            if (!hash) {
                return 0;
            }
            //Check for pending TX
            const lastTx = yield this.network.getPendingTransaction(hash);
            if (!lastTx) {
                return 0;
            }
            return 1 / dag4_core_1.DAG_DECIMALS;
        });
    }
    generateSignedTransaction(toAddress, amount, fee = 0, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            lastRef = lastRef
                ? lastRef
                : yield this.network.getAddressLastAcceptedTransactionRef(this.address);
            if (this.network.getNetworkVersion() === "2.0") {
                return dag4_keystore_1.keyStore.generateTransactionV2(amount, toAddress, this.keyTrio, lastRef, fee);
            }
            // Support old and new lastRef format
            if (lastRef && lastRef.hash && !lastRef.prevHash) {
                lastRef.prevHash = lastRef.hash;
            }
            return dag4_keystore_1.keyStore.generateTransaction(amount, toAddress, this.keyTrio, lastRef, fee);
        });
    }
    generateSignedTransactionWithHash(toAddress, amount, fee = 0, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            lastRef = lastRef
                ? lastRef
                : yield this.network.getAddressLastAcceptedTransactionRef(this.address);
            if (this.network.getNetworkVersion() === "2.0") {
                return dag4_keystore_1.keyStore.generateTransactionWithHashV2(amount, toAddress, this.keyTrio, lastRef, fee);
            }
            // Support old and new lastRef format
            if (lastRef && lastRef.hash && !lastRef.prevHash) {
                lastRef.prevHash = lastRef.hash;
            }
            return dag4_keystore_1.keyStore.generateTransactionWithHash(amount, toAddress, this.keyTrio, lastRef, fee);
        });
    }
    transferDag(toAddress, amount, fee = 0, autoEstimateFee = false, params) {
        return __awaiter(this, void 0, void 0, function* () {
            let normalizedAmount = Math.floor(new bignumber_js_1.BigNumber(amount).multipliedBy(dag4_core_1.DAG_DECIMALS).toNumber());
            const lastRef = yield this.network.getAddressLastAcceptedTransactionRef(this.address);
            if (fee === 0 && autoEstimateFee) {
                const tx = yield this.network.getPendingTransaction(lastRef.prevHash || lastRef.hash);
                if (tx) {
                    const addressObj = yield this.network.getAddressBalance(this.address);
                    //Check to see if sending max amount
                    if (addressObj.balance === normalizedAmount) {
                        amount -= dag4_core_1.DAG_DECIMALS;
                        normalizedAmount--;
                    }
                    fee = dag4_core_1.DAG_DECIMALS;
                }
            }
            const tx = yield this.generateSignedTransaction(toAddress, amount, fee);
            const txHash = yield this.network.postTransaction(tx, params);
            if (txHash) {
                return {
                    timestamp: Date.now(),
                    hash: txHash,
                    amount: amount,
                    receiver: toAddress,
                    fee,
                    sender: this.address,
                    ordinal: lastRef.ordinal,
                    pending: true,
                    status: "POSTED",
                };
            }
        });
    }
    waitForCheckPointAccepted(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            // In V2 the txn is accepted as it's processed so we don't need to check multiple times
            if (this.network.getNetworkVersion() === "2.0") {
                let txn;
                try {
                    txn = (yield this.network.getPendingTransaction(hash));
                }
                catch (err) {
                    // 404 NOOP
                }
                if (txn && txn.status === "Waiting") {
                    return true;
                }
                try {
                    yield this.network.getTransaction(hash);
                }
                catch (err) {
                    // 404s if not found
                    return false;
                }
                return true;
            }
            let attempts = 0;
            for (let i = 1;; i++) {
                const result = yield this.network.loadBalancerApi.checkTransactionStatus(hash);
                if (result) {
                    if (result.accepted) {
                        break;
                    }
                }
                else {
                    attempts++;
                    if (attempts > 20) {
                        throw new Error("Unable to find transaction");
                    }
                }
                yield this.wait(2.5);
            }
            return true;
        });
    }
    waitForBalanceChange(initialValue) {
        return __awaiter(this, void 0, void 0, function* () {
            if (initialValue === undefined) {
                initialValue = yield this.getBalance();
                yield this.wait(5);
            }
            let changed = false;
            //Run for a max of 2 minutes (5 * 24 times)
            for (let i = 1; i < 24; i++) {
                const result = yield this.getBalance();
                if (result !== undefined) {
                    if (result !== initialValue) {
                        changed = true;
                        break;
                    }
                }
                yield this.wait(5);
            }
            return changed;
        });
    }
    wait(time = 5) {
        return new Promise((resolve) => setTimeout(resolve, time * 1000));
    }
    // 2.0+ only
    generateBatchTransactions(transfers, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.network.getNetworkVersion() === "1.0") {
                throw new Error("transferDagBatch not available for mainnet 1.0");
            }
            if (!lastRef) {
                lastRef = (yield this.network.getAddressLastAcceptedTransactionRef(this.address));
            }
            const txns = [];
            for (const transfer of transfers) {
                const { transaction, hash } = yield this.generateSignedTransactionWithHash(transfer.address, transfer.amount, transfer.fee, lastRef);
                lastRef = {
                    hash,
                    ordinal: lastRef.ordinal + 1,
                };
                txns.push(transaction);
            }
            return txns;
        });
    }
    sendBatchTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.network.getNetworkVersion() === "1.0") {
                throw new Error("transferDagBatch not available for mainnet 1.0");
            }
            const hashes = [];
            for (const txn of transactions) {
                const hash = yield this.network.postTransaction(txn);
                hashes.push(hash);
            }
            return hashes;
        });
    }
    /**
     * @deprecated Use createAllowSpend() instead. This method will be removed in the next major version.
     */
    postAllowSpend(body) {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn("postAllowSpend() is deprecated. Use createAllowSpend() instead.");
            this.assertAccountIsActive();
            this.assertValidPrivateKey();
            (0, validationSchemas_1.validateSchema)(body, validationSchemas_1.postAllowSpendSchema, true);
            // Validate approvers array
            (0, validationSchemas_1.validateArraySchema)(body.approvers, validationSchemas_1.dagAddressValidator, true);
            const { source, destination, approvers, amount, fee, currencyId, validUntilEpoch, tokenL1Url, } = body;
            if (source !== this.address) {
                throw new Error('"source" must be the same as the account address');
            }
            let allowSpendLastRef = null;
            let signedAllowSpend = null;
            let allowSpendResponse = null;
            try {
                // Get allow spend last reference
                allowSpendLastRef =
                    yield this.network.l1Api.getAllowSpendLastRefDeprecated(tokenL1Url, this.address);
            }
            catch (err) {
                console.error("Error getting the allow spend last reference");
                throw err;
            }
            if (!allowSpendLastRef) {
                throw new Error("Unable to find allow spend last reference");
            }
            try {
                // Generate signed allow spend body
                const allowSpendBody = {
                    source,
                    amount,
                    destination,
                    approvers,
                    parent: allowSpendLastRef,
                    lastValidEpochProgress: validUntilEpoch,
                    currencyId: currencyId !== null && currencyId !== void 0 ? currencyId : null,
                    fee: fee !== null && fee !== void 0 ? fee : 0,
                };
                signedAllowSpend = yield dag4_keystore_1.keyStore.generateBrotliSignature(allowSpendBody, (0, utils_1.normalizePublicKey)(this.publicKey), this.m_keyTrio.privateKey);
            }
            catch (err) {
                console.error("Error generating the signed allow spend");
                throw err;
            }
            if (!signedAllowSpend) {
                throw new Error("Unable to generate signed allow spend");
            }
            try {
                // Post signed allow spend body
                allowSpendResponse = yield this.network.l1Api.postAllowSpendDeprecated(tokenL1Url, signedAllowSpend);
            }
            catch (err) {
                console.error("Error sending the allow spend transaction");
                throw err;
            }
            if (!allowSpendResponse) {
                throw new Error("Unable to get allow spend response");
            }
            return allowSpendResponse;
        });
    }
    createAllowSpend(body, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertAccountIsActive();
            this.assertValidPrivateKey();
            if (!body || typeof body !== "object") {
                throw new Error("body must be a valid object");
            }
            const bodyWithCurrencyId = Object.assign(Object.assign({}, body), { currencyId: null });
            return (0, operations_1.allowSpend)(bodyWithCurrencyId, this.network, this.keyTrio, params);
        });
    }
    /**
     * @deprecated Use createTokenLock() instead. This method will be removed in the next major version.
     */
    postTokenLock(body) {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn("postTokenLock() is deprecated. Use createTokenLock() instead.");
            this.assertAccountIsActive();
            this.assertValidPrivateKey();
            (0, validationSchemas_1.validateSchema)(body, validationSchemas_1.postTokenLockSchema, true);
            const { amount, currencyId, fee, source, tokenL1Url, unlockEpoch } = body;
            if (source !== this.address) {
                throw new Error('"source" must be the same as the account address');
            }
            let tokenLockLastRef = null;
            let signedTokenLock = null;
            let tokenLockResponse = null;
            try {
                // Get token lock last reference
                tokenLockLastRef = yield this.network.l1Api.getTokenLockLastRefDeprecated(tokenL1Url, this.address);
            }
            catch (err) {
                console.error("Error getting the token lock last reference");
                throw err;
            }
            if (!tokenLockLastRef) {
                throw new Error("Unable to find token lock last reference");
            }
            try {
                // Generate signed token lock body
                const tokenLockBody = {
                    source,
                    amount,
                    parent: tokenLockLastRef,
                    currencyId: currencyId !== null && currencyId !== void 0 ? currencyId : null,
                    fee: fee !== null && fee !== void 0 ? fee : 0,
                    unlockEpoch: unlockEpoch !== null && unlockEpoch !== void 0 ? unlockEpoch : null,
                };
                signedTokenLock = yield dag4_keystore_1.keyStore.generateBrotliSignature(tokenLockBody, (0, utils_1.normalizePublicKey)(this.publicKey), this.m_keyTrio.privateKey);
            }
            catch (err) {
                console.error("Error generating the signed token lock");
                throw err;
            }
            if (!signedTokenLock) {
                throw new Error("Unable to generate signed token lock");
            }
            try {
                // Post signed token lock body
                tokenLockResponse = yield this.network.l1Api.postTokenLockDeprecated(tokenL1Url, signedTokenLock);
            }
            catch (err) {
                console.error("Error sending the token lock transaction");
                throw err;
            }
            if (!tokenLockResponse) {
                throw new Error("Unable to get token lock response");
            }
            return tokenLockResponse;
        });
    }
    createTokenLock(body, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertAccountIsActive();
            this.assertValidPrivateKey();
            if (!body || typeof body !== "object") {
                throw new Error("body must be a valid object");
            }
            const bodyWithCurrencyId = Object.assign(Object.assign({}, body), { currencyId: null });
            return (0, operations_1.tokenLock)(bodyWithCurrencyId, this.network, this.keyTrio, params);
        });
    }
    /**
     * @deprecated Use createDelegatedStake() instead. This method will be removed in the next major version.
     */
    postDelegatedStake(body) {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn("postDelegatedStake() is deprecated. Use createDelegatedStake() instead.");
            return this.createDelegatedStake(body);
        });
    }
    createDelegatedStake(body) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertAccountIsActive();
            this.assertValidPrivateKey();
            (0, validationSchemas_1.validateSchema)(body, validationSchemas_1.delegatedStakeSchema, true);
            const { source, nodeId, amount, fee, tokenLockRef } = body;
            if (source !== this.address) {
                throw new Error('"source" must be the same as the account address');
            }
            let delegatedStakeLastRef = null;
            let signedDelegatedStake = null;
            let delegatedStakeResponse = null;
            try {
                // Get delegated stake last reference
                delegatedStakeLastRef = yield this.network.l0Api.getDelegatedStakeLastRef(this.address);
            }
            catch (err) {
                console.error("Error getting the delegated stake last reference");
                throw err;
            }
            if (!delegatedStakeLastRef) {
                throw new Error("Unable to find delegated stake last reference");
            }
            try {
                // Generate signed delegated stake body
                const delegateStakeBody = {
                    source,
                    nodeId,
                    amount,
                    tokenLockRef,
                    parent: delegatedStakeLastRef,
                    fee: fee !== null && fee !== void 0 ? fee : 0,
                };
                signedDelegatedStake = yield dag4_keystore_1.keyStore.generateBrotliSignature(delegateStakeBody, (0, utils_1.normalizePublicKey)(this.publicKey), this.m_keyTrio.privateKey);
            }
            catch (err) {
                console.error("Error generating the signed delegated stake");
                throw err;
            }
            if (!signedDelegatedStake) {
                throw new Error("Unable to generate signed delegated stake");
            }
            try {
                // Post signed delegated stake body
                delegatedStakeResponse = yield this.network.l0Api.postDelegatedStake(signedDelegatedStake);
            }
            catch (err) {
                console.error("Error sending the delegated stake transaction");
                throw err;
            }
            return delegatedStakeResponse;
        });
    }
    /**
     * @deprecated Use withdrawDelegatedStake() instead. This method will be removed in the next major version.
     */
    putWithdrawDelegatedStake(body) {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn("putWithdrawDelegatedStake() is deprecated. Use withdrawDelegatedStake() instead.");
            return this.withdrawDelegatedStake(body);
        });
    }
    withdrawDelegatedStake(body) {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertAccountIsActive();
            this.assertValidPrivateKey();
            (0, validationSchemas_1.validateSchema)(body, validationSchemas_1.withdrawDelegatedStakeSchema, true);
            if (body.source !== this.address) {
                throw new Error('"source" must be the same as the account address');
            }
            let signedWithdrawDelegatedStake = null;
            let withdrawDelegatedStakeResponse = null;
            try {
                signedWithdrawDelegatedStake = yield dag4_keystore_1.keyStore.generateBrotliSignature(body, (0, utils_1.normalizePublicKey)(this.publicKey), this.m_keyTrio.privateKey);
            }
            catch (err) {
                console.error("Error generating the withdraw delegated stake");
                throw err;
            }
            if (!signedWithdrawDelegatedStake) {
                throw new Error("Unable to generate signed withdraw delegated stake");
            }
            try {
                // Post signed withdraw delegated stake body
                withdrawDelegatedStakeResponse =
                    yield this.network.l0Api.putWithdrawDelegatedStake(signedWithdrawDelegatedStake);
            }
            catch (err) {
                console.error("Error sending the withdraw delegated stake transaction");
                throw err;
            }
            return withdrawDelegatedStakeResponse;
        });
    }
    transferDagBatch(transfers, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            const txns = yield this.generateBatchTransactions(transfers, lastRef);
            return this.sendBatchTransactions(txns);
        });
    }
    createMetagraphTokenClient(networkInfo) {
        return new metagraph_token_client_1.MetagraphTokenClient(this, networkInfo);
    }
}
exports.DagAccount = DagAccount;
//# sourceMappingURL=dag-account.js.map