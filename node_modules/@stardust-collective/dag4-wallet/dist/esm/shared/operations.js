var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { keyStore } from "@stardust-collective/dag4-keystore";
import { normalizePublicKey } from "../utils";
import { dagAddressValidator, allowSpendSchema, tokenLockSchema, validateArraySchema, validateSchema, } from "../validationSchemas";
export const allowSpend = (body, network, keyTrio, params) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    validateSchema(body, allowSpendSchema, true);
    // Validate approvers array
    validateArraySchema(body.approvers, dagAddressValidator, true);
    if (body.source !== keyTrio.address) {
        throw new Error('"source" must be the same as the account address');
    }
    let allowSpendLastRef = null;
    let signedAllowSpend = null;
    let allowSpendResponse = null;
    try {
        // Get allow spend last reference
        allowSpendLastRef = yield network.l1Api.getAllowSpendLastRef(keyTrio.address);
    }
    catch (err) {
        console.error("Error getting the allow spend last reference");
        throw err;
    }
    if (!allowSpendLastRef) {
        throw new Error("Unable to find allow spend last reference");
    }
    try {
        // Generate signed allow spend body
        const allowSpendBody = {
            source: body.source,
            destination: body.destination,
            approvers: body.approvers,
            amount: body.amount,
            parent: allowSpendLastRef,
            lastValidEpochProgress: body.validUntilEpoch,
            currencyId: (_a = body.currencyId) !== null && _a !== void 0 ? _a : null,
            fee: (_b = body.fee) !== null && _b !== void 0 ? _b : 0,
        };
        signedAllowSpend = yield keyStore.generateBrotliSignature(allowSpendBody, normalizePublicKey(keyTrio.publicKey), keyTrio.privateKey);
    }
    catch (err) {
        console.error("Error generating the signed allow spend");
        throw err;
    }
    if (!signedAllowSpend) {
        throw new Error("Unable to generate signed allow spend");
    }
    try {
        // Post signed allow spend body
        allowSpendResponse = yield network.l1Api.postAllowSpend(signedAllowSpend, params);
    }
    catch (err) {
        console.error("Error sending the allow spend transaction");
        throw err;
    }
    if (!allowSpendResponse || !allowSpendResponse.hash) {
        throw new Error("Unable to get allow spend response");
    }
    return allowSpendResponse;
});
export const tokenLock = (body, network, keyTrio, params) => __awaiter(void 0, void 0, void 0, function* () {
    var _c, _d, _e;
    validateSchema(body, tokenLockSchema, true);
    if (body.source !== keyTrio.address) {
        throw new Error('"source" must be the same as the account address');
    }
    let tokenLockLastRef = null;
    let signedTokenLock = null;
    let tokenLockResponse = null;
    try {
        // Get token lock last reference
        tokenLockLastRef = yield network.l1Api.getTokenLockLastRef(keyTrio.address);
    }
    catch (err) {
        console.error("Error getting the token lock last reference");
        throw err;
    }
    if (!tokenLockLastRef) {
        throw new Error("Unable to find token lock last reference");
    }
    try {
        // Generate signed token lock body
        const tokenLockBody = {
            source: body.source,
            amount: body.amount,
            parent: tokenLockLastRef,
            currencyId: (_c = body.currencyId) !== null && _c !== void 0 ? _c : null,
            fee: (_d = body.fee) !== null && _d !== void 0 ? _d : 0,
            unlockEpoch: (_e = body.unlockEpoch) !== null && _e !== void 0 ? _e : null,
        };
        signedTokenLock = yield keyStore.generateBrotliSignature(tokenLockBody, normalizePublicKey(keyTrio.publicKey), keyTrio.privateKey);
    }
    catch (err) {
        console.error("Error generating the signed token lock");
        throw err;
    }
    if (!signedTokenLock) {
        throw new Error("Unable to generate signed token lock");
    }
    try {
        // Post signed token lock body
        tokenLockResponse = yield network.l1Api.postTokenLock(signedTokenLock, params);
    }
    catch (err) {
        console.error("Error sending the token lock transaction");
        throw err;
    }
    if (!tokenLockResponse || !tokenLockResponse.hash) {
        throw new Error("Unable to get token lock response");
    }
    return tokenLockResponse;
});
//# sourceMappingURL=operations.js.map