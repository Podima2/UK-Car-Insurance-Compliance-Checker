"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeBrotli = exports.normalizeObject = void 0;
// // Initialize the compression function
const initBrotli = () => __awaiter(void 0, void 0, void 0, function* () {
    // In browser environments, use the bundled version
    if (typeof self !== 'undefined') {
        // Dynamic import for browser
        const brotliModule = require('brotli-wasm');
        return brotliModule.default || brotliModule;
    }
    else {
        // In Node.js, use the regular brotli package
        return require('brotli-wasm');
    }
});
// Promise to hold the compress function once initialized
const brotliPromise = initBrotli();
// Conditional import based on environment
const TextEncoderPolyfill = typeof TextEncoder === "undefined" ? require("util").TextEncoder : TextEncoder;
const removeNulls = (obj) => {
    const processValue = (value) => {
        if (value === null)
            return undefined;
        if (Array.isArray(value)) {
            return value.map((v) => processValue(v)).filter((v) => v !== undefined);
        }
        if (typeof value === "object") {
            return removeNulls(value);
        }
        return value;
    };
    return Object.entries(obj).reduce((acc, [key, value]) => {
        const processed = processValue(value);
        if (processed !== undefined) {
            acc[key] = processed;
        }
        return acc;
    }, {});
};
const sortObjectKeys = (obj) => {
    if (typeof obj !== "object" || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(sortObjectKeys);
    }
    return Object.keys(obj)
        .sort()
        .reduce((acc, key) => {
        acc[key] = sortObjectKeys(obj[key]);
        return acc;
    }, {});
};
const normalizeObject = (obj, sort = true, remove = true) => {
    const sorted = sort ? sortObjectKeys(obj) : obj;
    const removedNulls = remove ? removeNulls(sorted) : sorted;
    return removedNulls;
};
exports.normalizeObject = normalizeObject;
const serializeBrotli = (content, compressionLevel = 2) => __awaiter(void 0, void 0, void 0, function* () {
    // Get the brotli module
    const brotliModule = yield brotliPromise;
    const compress = brotliModule.compress;
    const normalized = (0, exports.normalizeObject)(content);
    const normalizedJson = JSON.stringify(normalized);
    const encoder = new TextEncoderPolyfill();
    const utf8Bytes = encoder.encode(normalizedJson);
    return compress(utf8Bytes, { quality: compressionLevel });
});
exports.serializeBrotli = serializeBrotli;
//# sourceMappingURL=utils.js.map